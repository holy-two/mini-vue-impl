# reactivity编写小结
学习reactivity包的过程，可以很明确的透彻关于依赖自动收集，以及延迟执行之类的代码实现。  
虽然经常类似的代码，但是很少会在这种工程化的代码里思考应用面，之前也多多少少接触过类似的解析文章，但是始终不如这次自己上手实现来的透彻。  
通读框架代码是一件不容易的事情，虽然我个人非常讨厌八股文，而且不屑于在面试的时候谈这些，但是本着兴趣的原则学习也是我的初衷，希望没有在面试里用到的一天。

## 如何实现自动依赖收集
其实收集的方式非常容易理解，那就是状态缓存。   
当任意的`ReactiveEffect`对象的run函数被执行时，就将它缓存到一个全局或者静态的变量上，我参考的对象的代码里采用的是一个全局变量，但是这个其实非常不符合我的习惯，因此我采用了更OOP的写法，采用了一个静态变量。  
这个变量的缓存会一直持续到下一个effect的run被执行时被替换，而在此期间只需要在对应track方法里获取到就可以，将当前的effect关联到reactive的每一个属性上。在代码的实现则采用了反射，map，set等概念，其实采用普通的对象属性也可以，但是会徒增很多实现的成本。而采用这些也是为了方便获取，所以这些东西本身也算是最佳选择了。

## 关于类型
项目参考的代码原始的ts应用其实非常的基础，基本上没有考虑到类型安全的问题，所以我在编写的时候特别注意了类型问题，不过目前类型在实现上也还是有点问题，个人的~~借口~~是，这只是一个拿来理解开发过程的代码库，所以暂时不需要考虑生产环境的使用。  
另外，GitHub Copilot真香，我写个名字，自己就开始做类型体操了。